```=toml
title = "2025 Advent of Code"
date = 2025-12-01
keywords = ["Advent of Code 2025", "puzzles"]
description = ""
```

# 2025 Advent of Code Summary

Note: the number of problems has been changed from 25 to 12 this year.

``` text
Day   -Part 1-   -Part 2-
  7   00:09:25   00:13:45
  6   00:04:06   00:07:46
  5   00:03:50   00:06:40
  4   00:04:18   00:08:48
  3   00:03:38   00:09:51
  2   00:05:01   00:23:55
  1   00:02:54   00:12:32
```

## Day 7
1. Brute-force. For some reason, I thought it asks to count how many `|` at the end...
2. DP. Define `f(r, c)` that returns the number of timelines from cell `(r, c)` downward (splitting on `^`), and memorize it so each cell's count is computed once and reused. 

``` txt
fn dp(r, c):
  if r == last_row:
    return 1
  if grid[r+1][c] == '^':   // splitter below
    return dp(r + 1, c - 1) + dp(r + 1, c + 1)
  else:                     // straight down
    return dp(r + 1, c)
```

## Day 6

1. Split by space, then simulation.
2. Split it into vertical problem block at all-space columns, then for each block read digits top-to-bottom in each column (right to left) to form numbers.

``` python
g = [list(r.ljust(w)) for r in rows]
sep = [all(g[r][c] == ' ' for r in range(h)) for c in range(w)]
```


## Day 5

1. Brute-force.
2. [Merge intervals](https://leetcode.com/problems/merge-intervals/description/).

## Day 4

1. Simulation.
2. Simulation, but multiple rounds.  

## Day 3

1. Brute-force.
2. Treat each row as: "remove some digits so the remaining 12 are as big as possible from left to right". Hint: use monotonic stack. 

## Day 2

1. Brute-force. For each range `(l, r)`, check all integers from 1 up to half the number of digits in `r`, inclusive. 
2. Similar idea, but remember to handle duplicates. For example, `1111` can be represented as `1` repeated four times or `11` repeated two times. 

## Day 1

1. Modular arithmetic.
2. Brute-force.

{.edited}
Last edited: Dec 06, 2025